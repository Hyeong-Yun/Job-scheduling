# 작업 스케줄링(Job Scheduling)

n개의 작업, 각 작업의 수행 시간, m개의 동일한 기계가 주어질 떄, 모든 작업이 가장 빨리 종료 되도록 작업을 기계에 배정하는 문제. 단, 한 작업은 배정된 기계에서 연속적으로 수행되어야 한다. 또한 기께는 1번에 하나의 작업만을 수행한다.

## 코드 설명
- 그리디 방법으로 작업을 배정한다.
- 입력 : n개의 작업, 각 작업 수행 시간, 기계의 수 
- 출력 : 모든 작업이 종료된 시간

```의사코드
// pseudocode
for j = 1 to m
L[j] = 0
for i = 1 to n{
  min = 1
  for j = 2 to m
    if(L[j] < L[min]){
      min = j
    }

  작업 ifmf 기계 M(min)에 배정한다.
  L[min] = L[min]+t(i)
}
return 가장 늦은 작업 종료 시간
```

1. 초기에는 어떤 작업도 기계에 배정되지 않은 상태이기 때문에 각 기계에 배정된 마지막 작업의 종료 시간 L[j]를 0으로 초기화시킨다.
2. for 루프에서는 n개의 작업을 1개씩 가장 일찍 끝나는 기계에 배정한다.
3. 가장 일찍 끝나는 기계의 번호인 min을 1(즉, 기계 M(1))로 초기화 시킨다.
4. for루프에서는 각 기계의 마지막 작업의 종료 시간을 검사하여, min을 찾는다.
5. 작업 i를 기계 M(min)에 배정하고, L[min]을 작업 i의 수행 시간을 더하여 갱신한다.
6. 배열 L에서 가장 큰 값을 찾아서 리턴한다.

## 시간 복잡도
- n개의 작업을 하나씩 가장 빨리 끝나는 기계에 배정하고, 가장 일찍 끝나는 기계를 찾기 위해 반복문이 m-1번 수행된다. => nxO(n)
- 각 기계에 배정된 마지막 작업의 종료시간 살펴보기 : O(m)
- 따라서, 시간복잡도 : nO(m) + O(m) = O(nm)

## 근사 비율
근사해를 OPT'라 하고, 최적해를 OPT라고 할 떄, OPT' <= 2xOPT이다.
- 근사해는 최적해의 2배를 넘지 않는다.

### T <= T'를 이용한 증명
<img width="604" alt="작업스케줄링" src="https://user-images.githubusercontent.com/81741589/118929951-1c7f7680-b980-11eb-8f9f-9c5cce5052a8.png">

- T'은 작업 i를 제외한 평균 종료 시간이다. 따라서 작업 i가 배정된 기계를 제외한 모든 기계에 배정된 작업은 적어도 T 이후에 종료되기 때문에 T <= T'이 된다.
- T<=T' 관계를 이용한 OPT' <= 2xOPT 증명

<img width="604" alt="작업스케줄링" src="https://user-images.githubusercontent.com/81741589/118929951-1c7f7680-b980-11eb-8f9f-9c5cce5052a8.png">

<img width="535" alt="T =증명" src="https://user-images.githubusercontent.com/81741589/118929876-083b7980-b980-11eb-90de-4581aed4e3d5.png">
## Brute Force, Greedy 방식의 비교
